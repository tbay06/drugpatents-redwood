{
  "version": 3,
  "sources": ["../../src/lib/auth.js"],
  "sourcesContent": ["// Define what you want `currentUser` to return throughout your app. For example,\r\n// to return a real user from your database, you could do something like:\r\n//\r\n//   export const getCurrentUser = async ({ email }) => {\r\n//     return await db.user.fineUnique({ where: { email } })\r\n//   }\r\n//\r\n// If you want to enforce role-based access ...\r\n//\r\n// You'll need to set the currentUser's roles attributes to the\r\n// collection of roles as defined by your app.\r\n//\r\n// This allows requireAuth() on the api side and hasRole() in the useAuth() hook on the web side\r\n// to check if the user is assigned a given role or not.\r\n//\r\n// How you set the currentUser's roles depends on your auth provider and its implementation.\r\n//\r\n// For example, your decoded JWT may store `roles` in it namespaced `app_metadata`:\r\n//\r\n// {\r\n//   'https://example.com/app_metadata': { authorization: { roles: ['admin'] } },\r\n//   'https://example.com/user_metadata': {},\r\n//   iss: 'https://app.us.auth0.com/',\r\n//   sub: 'email|1234',\r\n//   aud: [\r\n//     'https://example.com',\r\n//     'https://app.us.auth0.com/userinfo'\r\n//   ],\r\n//   iat: 1596481520,\r\n//   exp: 1596567920,\r\n//   azp: '1l0w6JXXXXL880T',\r\n//   scope: 'openid profile email'\r\n// }\r\n//\r\n// The parseJWT utility will extract the roles from decoded token.\r\n//\r\n// The app_medata claim may or may not be namespaced based on the auth provider.\r\n// Note: Auth0 requires namespacing custom JWT claims\r\n//\r\n// Some providers, such as with Auth0, will set roles an authorization\r\n// attribute in app_metadata (namespaced or not):\r\n//\r\n// 'app_metadata': { authorization: { roles: ['publisher'] } }\r\n// 'https://example.com/app_metadata': { authorization: { roles: ['publisher'] } }\r\n//\r\n// Other providers may include roles simply within app_metadata:\r\n//\r\n// 'app_metadata': { roles: ['author'] }\r\n// 'https://example.com/app_metadata': { roles: ['author'] }\r\n//\r\n// And yet other may define roles as a custom claim at the root of the decoded token:\r\n//\r\n// roles: ['admin']\r\n//\r\n// The function `getCurrentUser` should return the user information\r\n// together with a collection of roles to check for role assignment:\r\n\r\nimport { AuthenticationError, ForbiddenError, parseJWT } from '@redwoodjs/api'\r\n\r\n/**\r\n * Use requireAuth in your services to check that a user is logged in,\r\n * whether or not they are assigned a role, and optionally raise an\r\n * error if they're not.\r\n *\r\n * @param {string=, string[]=} role - An optional role\r\n *\r\n * @example - No role-based access control.\r\n *\r\n * export const getCurrentUser = async (decoded) => {\r\n *   return await db.user.fineUnique({ where: { decoded.email } })\r\n * }\r\n *\r\n * @example - User info is conatined in the decoded token and roles extracted\r\n *\r\n * export const getCurrentUser = async (decoded, { _token, _type }) => {\r\n *   return { ...decoded, roles: parseJWT({ decoded }).roles }\r\n * }\r\n *\r\n * @example - User record query by email with namespaced app_metadata roles\r\n *\r\n * export const getCurrentUser = async (decoded) => {\r\n *   const currentUser = await db.user.fineUnique({ where: { email: decoded.email } })\r\n *\r\n *   return {\r\n *     ...currentUser,\r\n *     roles: parseJWT({ decoded: decoded, namespace: NAMESPACE }).roles,\r\n *   }\r\n * }\r\n *\r\n * @example - User record query by an identity with app_metadata roles\r\n *\r\n * const getCurrentUser = async (decoded) => {\r\n *   const currentUser = await db.user.fineUnique({ where: { userIdentity: decoded.sub } })\r\n *   return {\r\n *     ...currentUser,\r\n *     roles: parseJWT({ decoded: decoded }).roles,\r\n *   }\r\n * }\r\n */\r\nexport const getCurrentUser = async (decoded, { _token, _type }) => {\r\n  return { ...decoded, roles: parseJWT({ decoded }).roles }\r\n}\r\n\r\n/**\r\n * Use requireAuth in your services to check that a user is logged in,\r\n * whether or not they are assigned a role, and optionally raise an\r\n * error if they're not.\r\n *\r\n * @param {string=} roles - An optional role or list of roles\r\n * @param {string[]=} roles - An optional list of roles\r\n\r\n * @example\r\n *\r\n * // checks if currentUser is authenticated\r\n * requireAuth()\r\n *\r\n * @example\r\n *\r\n * // checks if currentUser is authenticated and assigned one of the given roles\r\n * requireAuth({ role: 'admin' })\r\n * requireAuth({ role: ['editor', 'author'] })\r\n * requireAuth({ role: ['publisher'] })\r\n */\r\nexport const requireAuth = ({ role } = {}) => {\r\n  if (!context.currentUser) {\r\n    throw new AuthenticationError(\"You don't have permission to do that.\")\r\n  }\r\n\r\n  if (\r\n    typeof role !== 'undefined' &&\r\n    typeof role === 'string' &&\r\n    !context.currentUser.roles?.includes(role)\r\n  ) {\r\n    throw new ForbiddenError(\"You don't have access to do that.\")\r\n  }\r\n\r\n  if (\r\n    typeof role !== 'undefined' &&\r\n    Array.isArray(role) &&\r\n    !context.currentUser.roles?.some((r) => role.includes(r))\r\n  ) {\r\n    throw new ForbiddenError(\"You don't have access to do that.\")\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAyDA,iBAA8D;AA0CvD,MAAM,iBAAiB,OAAO,SAAS;EAAE;EAAQ;MAAY;AAClE,SAAO,iCAAK,UAAL;IAAc,OAAO,yBAAS;MAAE;OAAW;;;AAuB7C,MAAM,cAAc,CAAC;EAAE;IAAS,OAAO;AA3H9C;AA4HE,MAAI,CAAC,mBAAQ,aAAa;AACxB,UAAM,IAAI,+BAAoB;;AAGhC,MACE,OAAO,SAAS,eAChB,OAAO,SAAS,YAChB,CAAC,0BAAQ,YAAY,UAApB,mBAA2B,SAAS,QACrC;AACA,UAAM,IAAI,0BAAe;;AAG3B,MACE,OAAO,SAAS,eAChB,MAAM,QAAQ,SACd,CAAC,0BAAQ,YAAY,UAApB,mBAA2B,KAAM,OAAM,KAAK,SAAS,MACtD;AACA,UAAM,IAAI,0BAAe;;;",
  "names": []
}
